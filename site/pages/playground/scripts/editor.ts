import { appendTerminalLine, revealOutputWindow, setTerminalCollapsed, clearTerminal } from "./terminal.ts";
import { EditorState } from "@codemirror/state"
import { keymap } from "@codemirror/view"
import { EditorView, basicSetup } from "codemirror"
import { JsonRpcMessage, LspClient } from "./lsp";
import { indentWithTab } from "@codemirror/commands";
import { indentUnit } from "@codemirror/language";
import { editorTheme, editorHighlightStyle } from "./theme.ts";
import zigMainSource from './template/main.zig' with { type: "text" };
import zxModSource from './template/Playground.zx' with { type: "text" };
import zxstylecss from './template/style.css' with { type: "text" };
import { fileManager, PlaygroundFile } from "./file";
import { html } from "@codemirror/lang-html";
import { css } from "@codemirror/lang-css";
import { javascript } from "@codemirror/lang-javascript";

export default class ZlsClient extends LspClient {
    public worker: Worker;

    constructor(worker: Worker) {
        super("file:///", []);
        this.worker = worker;
        this.autoClose = false;

        this.worker.addEventListener("message", this.messageHandler);
    }

    private messageHandler = (ev: MessageEvent) => {
        const data = JSON.parse(ev.data);

        if (data.method == "window/logMessage") {
            if (!data.stderr) {
                switch (data.params.type) {
                    case 5:
                        console.debug("ZLS --- ", data.params.message);
                        break;
                    case 4:
                        console.log("ZLS --- ", data.params.message);
                        break;
                    case 3:
                        console.info("ZLS --- ", data.params.message);
                        break;
                    case 2:
                        console.warn("ZLS --- ", data.params.message);
                        break;
                    case 1:
                        console.error("ZLS --- ", data.params.message);
                        break;
                    default:
                        console.error(data.params.message);
                        break;
                }
            }
        } else {
            console.debug("LSP <<-", data);
        }
        this.handleMessage(data);
    };

    public async sendMessage(message: JsonRpcMessage): Promise<void> {
        console.debug("LSP ->>", message);
        if (this.worker) {
            this.worker.postMessage(JSON.stringify(message));
        }
    }

    public async close(): Promise<void> {
        super.close();
        this.worker.terminate();
    }
}

let client = new ZlsClient(new Worker('/assets/playground/workers/zls.js'));


interface EditorFile {
    name: string;
    state: EditorState;
    hidden?: boolean;
    locked?: boolean; // if true, file cannot be renamed or deleted
}

let files: EditorFile[] = [];
let activeFileIndex = -1;
let editorView: EditorView;

function createEditorState(filename: string, content: string) {
    const extensions = [
        basicSetup,
        editorTheme,
        editorHighlightStyle,
        indentUnit.of("    "),
        keymap.of([indentWithTab]),
    ];

    if (filename.endsWith('.zig') || filename.endsWith('.zx') || filename.endsWith('.zon')) {
        extensions.push(client.createPlugin(`file:///${filename}`, "zig", true));
    }

    // Add HTML highlighting for .zx files
    if (filename.endsWith(".zx") || filename.endsWith(".html")) {
        extensions.push(html());
    } else if (filename.endsWith(".css")) {
        extensions.push(css());
    } else if (filename.endsWith(".js") || filename.endsWith(".jsx")) {
        extensions.push(javascript({ jsx: true }));
    } else if (filename.endsWith(".ts") || filename.endsWith(".tsx")) {
        extensions.push(javascript({ jsx: true, typescript: true }));
    }
    return EditorState.create({
        doc: content,
        extensions,
    });
}

function getFileClass(filename: string): string {
    if (filename.endsWith('.zig')) return 'zig';
    if (filename.endsWith('.zx')) return 'zx';
    if (filename.endsWith('.css')) return 'css';
    if (filename.endsWith('.html')) return 'html';
    if (filename.endsWith('.md')) return 'md';
    if (filename.endsWith('.jsx')) return 'jsx';
    if (filename.endsWith('.tsx')) return 'tsx';
    if (filename.endsWith('.js')) return 'js';
    if (filename.endsWith('.ts')) return 'ts';
    return 'file';
}

function updateTabs() {
    const tabsContainer = document.getElementById("pg-tabs")!;
    // Remove all tab buttons but keep the add-file button
    const addBtn = document.getElementById("pg-add-file");
    tabsContainer.innerHTML = "";

    files.forEach((file, index) => {
        if (file.hidden) return;
        const tab = document.createElement("button");
        tab.className = `pg-tab${index === activeFileIndex ? " pg-tab--active" : ""}`;
        tab.setAttribute("data-file", file.name);
        tab.id = `pg-tab-${index}`;

        const iconSpan = document.createElement("span");
        iconSpan.className = `pg-tab-icon type-${getFileClass(file.name)}`;
        const template = document.getElementById("pg-icons-template") as HTMLTemplateElement;
        if (template) {
            iconSpan.appendChild(template.content.cloneNode(true));
        }
        tab.appendChild(iconSpan);

        tab.appendChild(document.createTextNode(file.name));

        const closeBtn = document.createElement("span");
        closeBtn.className = "pg-tab-close";
        closeBtn.setAttribute("aria-label", "Close tab");
        closeBtn.innerHTML = "Ã—";
        if (file.locked) {
            closeBtn.style.opacity = "0.3";
            closeBtn.style.pointerEvents = "none";
            closeBtn.title = "Main playground file: cannot rename or close, and fn Playground must exist in it";
        } else {
            closeBtn.onclick = (e) => {
                e.stopPropagation();
                removeFile(index);
            };
        }
        tab.appendChild(closeBtn);

        tab.onclick = () => switchFile(index);
        if (!file.locked) {
            tab.ondblclick = () => renameFile(index);
        } else {
            tab.ondblclick = null;
            tab.title = "Main playground file: cannot rename or close, and fn Playground must exist in it";
        }

        tabsContainer.appendChild(tab);
    });

    if (addBtn) {
        tabsContainer.appendChild(addBtn);
    } else {
        const newAddBtn = document.createElement("button");
        newAddBtn.className = "pg-tab-add";
        newAddBtn.id = "pg-add-file";
        newAddBtn.setAttribute("aria-label", "Add new file");
        newAddBtn.title = "New file";
        newAddBtn.textContent = "+";
        newAddBtn.addEventListener("click", addFile);
        tabsContainer.appendChild(newAddBtn);
    }
}

async function switchFile(index: number) {
    if (index === activeFileIndex) return;

    if (activeFileIndex !== -1 && editorView) {
        files[activeFileIndex].state = editorView.state;
        fileManager.updateContent(files[activeFileIndex].name, editorView.state.doc.toString());
    }

    activeFileIndex = index;
    const file = files[index];

    if (!editorView) {
        editorView = new EditorView({
            state: file.state,
            parent: document.getElementById("pg-code-area")!,
        });
    } else {
        editorView.setState(file.state);
    }

    updateTabs();
}

function addFile() {
    let name = "untitled.zx";
    let counter = 0;
    while (fileManager.hasFile(name)) {
        counter++;
        name = `untitled${counter}.zx`;
    }

    const promptedName = prompt("File name:", name);
    if (!promptedName) return;

    if (fileManager.hasFile(promptedName)) {
        alert("File already exists!");
        return;
    }

    fileManager.addFile(promptedName, "");
    const newFile: EditorFile = {
        name: promptedName,
        state: createEditorState(promptedName, ""),
    };
    files.push(newFile);
    switchFile(files.length - 1);
}

function removeFile(index: number) {
    if (files[index].locked) {
        alert("This file is locked and cannot be deleted.");
        return;
    }
    fileManager.removeFile(files[index].name);
    files.splice(index, 1);
    if (activeFileIndex >= files.length) {
        activeFileIndex = files.length - 1;
    }
    switchFile(activeFileIndex);
    updateTabs();
}

function renameFile(index: number) {
    const file = files[index];
    if (file.locked) {
        alert("This file is locked and cannot be renamed.");
        return;
    }
    const newName = prompt("Rename file:", file.name);
    if (newName && newName !== file.name) {
        if (fileManager.hasFile(newName)) {
            alert("File already exists!");
            return;
        }
        const content = file.state.doc.toString();
        if (fileManager.renameFile(file.name, newName)) {
            file.name = newName;
            file.state = createEditorState(newName, content);
            if (index === activeFileIndex) {
                editorView.setState(file.state);
            }
            updateTabs();
        } else {
            alert("Rename failed!");
        }
    }
}



async function encodeFilesToQuery(filesMap: { [filename: string]: string }): Promise<string> {
    const filtered: { [filename: string]: string } = {};
    for (const [name, content] of Object.entries(filesMap)) {
        filtered[name] = content;
    }
    const json = JSON.stringify(filtered);
    const stream = new Blob([json]).stream().pipeThrough(new CompressionStream("deflate"));
    const buffer = await new Response(stream).arrayBuffer();

    let binString = '';
    const bytes = new Uint8Array(buffer);
    const CHUNK_SIZE = 0x8000;
    for (let i = 0; i < bytes.length; i += CHUNK_SIZE) {
        binString += String.fromCharCode.apply(null, Array.from(bytes.subarray(i, i + CHUNK_SIZE)));
    }
    const b64 = btoa(binString);
    return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

async function decodeFilesFromQuery(query: string): Promise<{ [filename: string]: string } | null> {
    try {
        let b64 = query.replace(/-/g, '+').replace(/_/g, '/');
        while (b64.length % 4) {
            b64 += '=';
        }
        const binString = atob(b64);
        const bytes = Uint8Array.from(binString, (m) => m.codePointAt(0)!);

        const stream = new Blob([bytes]).stream().pipeThrough(new DecompressionStream("deflate"));
        const text = await new Response(stream).text();
        return JSON.parse(text);
    } catch {
        return null;
    }
}

function copyToClipboard(text: string) {
    if (navigator.clipboard) {
        navigator.clipboard.writeText(text);
    } else {
        const textarea = document.createElement("textarea");
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand("copy");
        document.body.removeChild(textarea);
    }
}

function showShareSuccess() {
    const btn = document.getElementById("pg-share-btn");
    if (!btn) return;
    const orig = btn.innerHTML;
    btn.innerHTML = '<span style="vertical-align:middle;display:inline-block;width:1em;height:1em;margin-right:0.3em;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" width="1em" height="1em"><path fill-rule="evenodd" d="M16.704 6.29a1 1 0 0 1 0 1.42l-6.004 6a1 1 0 0 1-1.416 0l-2.996-3a1 1 0 1 1 1.416-1.42l2.288 2.29 5.296-5.29a1 1 0 0 1 1.416 0z" clip-rule="evenodd"/></svg></span>Copied!';
    setTimeout(() => { btn.innerHTML = orig; }, 1200);
}

document.getElementById("pg-share-btn")?.addEventListener("click", async () => {
    const filesMap = getCurrentFilesMap();
    const encoded = await encodeFilesToQuery(filesMap);
    const url = `${location.origin}${location.pathname}#code=${encoded}`;

    if (url.length > 8000) {
        alert(`Warning: This share link is ${url.length} characters long. Older browsers, proxies, or chat apps max out at 2,000-8,000 bytes and might truncate it, breaking the link.`);
    }

    copyToClipboard(url);
    showShareSuccess();

});

function loadTemplateFiles() {
    fileManager.addFile("Playground.zx", zxModSource);
    fileManager.addFile("main.zig", zigMainSource);
    fileManager.addFile("style.css", zxstylecss);
}


window.addEventListener("DOMContentLoaded", async () => {
    await client.initialize();

    // Use hash fragment for code sharing
    let code = null;
    if (location.hash.startsWith("#code=")) {
        code = location.hash.slice(6);
    }
    let initialFileIndex = 0;
    if (code) {
        const filesDecoded = await decodeFilesFromQuery(code);
        if (filesDecoded) {
            fileManager.getAllFiles().forEach(f => fileManager.removeFile(f.name));
            Object.entries(filesDecoded).forEach(([name, content]) => fileManager.addFile(name, content));
            const newFiles = fileManager.getAllFiles().map(f => ({
                name: f.name,
                state: createEditorState(f.name, f.content),
                hidden: f.name === "main.zig",
                locked: f.name === "Playground.zx" || f.name === "main.zig",
            }));
            files.length = 0;
            files.push(...newFiles);
            updateTabs();
            await switchFile(initialFileIndex);
            // Force re-setting the state to trigger LSP plugin
            if (editorView && files[initialFileIndex]) {
                editorView.setState(files[initialFileIndex].state);
            }
            return;
        }
    }
    loadTemplateFiles();
    const newFiles = fileManager.getAllFiles().map(f => ({
        name: f.name,
        state: createEditorState(f.name, f.content),
        hidden: f.name === "main.zig",
        locked: f.name === "Playground.zx" || f.name === "main.zig",
    }));
    files.length = 0;
    files.push(...newFiles);
    updateTabs();
    await switchFile(initialFileIndex);
    if (editorView && files[initialFileIndex]) {
        editorView.setState(files[initialFileIndex].state);
    }
});

// Only initialize client here, file loading is handled in DOMContentLoaded
(async () => {
    // await client.initialize();
})();

document.getElementById("pg-add-file")?.addEventListener("click", addFile);

// Convert vertical mouse wheel to horizontal scroll on the tabs bar
const tabsEl = document.getElementById("pg-tabs")!;
tabsEl.addEventListener("wheel", (e) => {
    if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
        e.preventDefault();
        tabsEl.scrollLeft += e.deltaY;
    }
}, { passive: false });

// Show/hide right scroll shadow when tabs overflow
function updateTabsScrollShadow() {
    const hasOverflowRight = tabsEl.scrollLeft + tabsEl.clientWidth < tabsEl.scrollWidth - 1;
    tabsEl.classList.toggle("scroll-shadow-right", hasOverflowRight);
}
tabsEl.addEventListener("scroll", updateTabsScrollShadow);
new ResizeObserver(updateTabsScrollShadow).observe(tabsEl);
new MutationObserver(updateTabsScrollShadow).observe(tabsEl, { childList: true });


let zigWorker = new Worker('/assets/playground/workers/zig.js');
let zxWorker = new Worker('/assets/playground/workers/zx.js');

function setRunButtonLoading(loading: boolean) {
    const btn = document.getElementById("pg-run-btn")!;
    if (loading) {
        btn.classList.add("pg-nav-btn--loading");
        btn.setAttribute("disabled", "true");
        btn.innerHTML = '<span class="pg-spinner"></span>';
    } else {
        btn.classList.remove("pg-nav-btn--loading");
        btn.removeAttribute("disabled");
        btn.innerHTML = 'â–¶ Run';
    }
}


zxWorker.onmessage = (ev: MessageEvent) => {
    console.info("Transpiled finished in", (performance.now() - build_start_time).toFixed(2), "ms");
    console.debug("ZX Worker ->>", ev.data);
}

zigWorker.onmessage = (ev: MessageEvent) => {
    console.info("Build finished in", (performance.now() - build_start_time).toFixed(2), "ms");

    if (ev.data.stderr) {
        // Append compiler stderr as error lines
        const lines = ev.data.stderr.split('\n').filter((l: string) => l.length > 0);
        for (const l of lines) {
            appendTerminalLine(l, "pg-terminal-error");
        }
        setTerminalCollapsed(false);
        revealOutputWindow();
        setRunButtonLoading(false);
        return;
    } else if (ev.data.failed) {
        appendTerminalLine("Compilation failed.", "pg-terminal-error");
        setTerminalCollapsed(false);
        revealOutputWindow();
        setRunButtonLoading(false);
    } else if (ev.data.compiled) {
        let runnerWorker = new Worker('/assets/playground/workers/runner.js');
        runnerWorker.postMessage({ run: ev.data.compiled });
        runnerWorker.onmessage = (rev: MessageEvent) => {
            if (rev.data.stderr) {
                const lines = rev.data.stderr.split('\n').filter((l) => l.length > 0);
                for (const l of lines) {
                    appendTerminalLine(l, "pg-terminal-error");
                }
                setTerminalCollapsed(false);
                revealOutputWindow();
                setRunButtonLoading(false);
                return;
            }
            if (rev.data.preview) {
                const viewport = document.getElementById("pg-browser-viewport")!;
                let iframe = viewport.querySelector("iframe") as HTMLIFrameElement;
                if (!iframe) {
                    viewport.innerHTML = "";
                    iframe = document.createElement("iframe");
                    iframe.style.width = "100%";
                    iframe.style.height = "100%";
                    iframe.style.border = "none";
                    iframe.style.backgroundColor = "white";
                    viewport.appendChild(iframe);
                    iframe.contentDocument?.open();
                }
                iframe.contentDocument?.write(rev.data.preview);
                return;
            }
            if (rev.data.done) {
                const viewport = document.getElementById("pg-browser-viewport")!;
                const iframe = viewport.querySelector("iframe") as HTMLIFrameElement;
                if (iframe) {
                    iframe.contentDocument?.close();
                }
                runnerWorker.terminate();
                // appendTerminalLine("Program exited.\n", "pg-terminal-muted");
                setRunButtonLoading(false);
            }
        };
    }
}


let build_start_time = performance.now();

function getCurrentFilesMap(): { [filename: string]: string } {
    if (activeFileIndex !== -1 && editorView) {
        fileManager.updateContent(files[activeFileIndex].name, editorView.state.doc.toString());
    }
    const filesMap: { [filename: string]: string } = {};
    fileManager.getAllFiles().forEach(f => {
        const fileObj = files.find(file => file.name === f.name);
        if (fileObj && fileObj.hidden) return;
        filesMap[f.name] = f.content;
    });
    return filesMap;
}

const outputsRun = document.getElementById("pg-run-btn")! as HTMLButtonElement;
outputsRun.addEventListener("click", async () => {
    setRunButtonLoading(true);
    clearTerminal();
    const viewport = document.getElementById("pg-browser-viewport")!;
    while (viewport.firstChild) viewport.removeChild(viewport.firstChild);
    const placeholder = document.createElement("div");
    placeholder.className = "pg-browser-placeholder";
    const icon = document.createElement("div");
    icon.className = "pg-browser-placeholder-icon";
    icon.textContent = "ðŸŒ";
    placeholder.appendChild(icon);
    placeholder.appendChild(document.createTextNode("Buildingâ€¦"));
    viewport.appendChild(placeholder);

    let filesMap = getCurrentFilesMap();
    if (!filesMap["main.zig"]) {
        filesMap["main.zig"] = zigMainSource;
    }
    const zxFiles = Object.entries(filesMap).filter(([name]) => name.endsWith('.zx'));
    let transpiledZigFiles: { [filename: string]: string } = {};

    // Helper to transpile a single .zx file and return a Promise
    function transpileZxFile(zxName: string, zxContent: string): Promise<{ [filename: string]: string }> {
        return new Promise((resolve, reject) => {
            const handler = (ev: MessageEvent) => {
                console.log('[DEBUG] zxWorker message:', ev.data);
                if (ev.data && ev.data.filename && ev.data.transpiled) {
                    zxWorker.removeEventListener('message', handler);
                    resolve({ [ev.data.filename]: ev.data.transpiled });
                } else if (ev.data && ev.data.failed) {
                    zxWorker.removeEventListener('message', handler);
                    appendTerminalLine(ev.data.stderr || "Transpile failed", "pg-terminal-error");
                    setTerminalCollapsed(false);
                    revealOutputWindow();
                    setRunButtonLoading(false);
                    reject(ev.data.stderr);
                } else if (ev.data && ev.data.stdout) {
                    zxWorker.removeEventListener('message', handler);
                    const zigName = zxName.replace(/\.zx$/, ".zig");
                    console.log('[DEBUG] Treating stdout as transpiled .zig for', zigName);
                    resolve({ [zigName]: ev.data.stdout });
                }
            };

            zxWorker.addEventListener('message', handler);
            console.log('[DEBUG] Posting to zxWorker:', zxName);
            zxWorker.postMessage({ filename: zxName, content: zxContent });
        });
    }

    for (const [zxName, zxContent] of zxFiles) {
        console.log('[DEBUG] Transpiling', zxName);
        try {
            transpiledZigFiles = await transpileZxFile(zxName, zxContent);
            console.log('[DEBUG] Transpiled result:', transpiledZigFiles);
            Object.assign(filesMap, transpiledZigFiles);
            const zigName = Object.keys(transpiledZigFiles)[0];
            const zigContent = transpiledZigFiles[zigName];
            if (fileManager.hasFile(zigName)) {
                fileManager.updateContent(zigName, zigContent);
                let zigFile = files.find(f => f.name === zigName);
                if (zigFile) {
                    zigFile.state = createEditorState(zigName, zigContent);
                    zigFile.hidden = true;
                }
            } else {
                fileManager.addFile(zigName, zigContent);
                files.push({ name: zigName, state: createEditorState(zigName, zigContent), hidden: true });
            }
        } catch (err) {
            console.error('[DEBUG] Transpile error:', err);
            return;
        }
    }

    console.log('[DEBUG] Sending files to zigWorker:', Object.keys(filesMap));
    build_start_time = performance.now();
    zigWorker.postMessage({ files: filesMap });
});
