const components = data.components;

var inputvalue: []const u8 = "";
var stateFilter: []const u8 = "";

var selected_component = zx.Signal([]const u8).init("App");

// Helper function to find a component by name recursively
fn findComponentByName(comps: []const data.Component, name: []const u8) ?data.Component {
    for (comps) |comp| {
        if (std.mem.eql(u8, comp.name, name)) {
            return comp;
        }
        if (comp.has_children) {
            if (findComponentByName(comp.children, name)) |found| {
                return found;
            }
        }
    }
    return null;
}

const ComponentSearchInputProps = struct {  };
const ComponentStateProps = struct {  };
const ComponentTreeProps = struct {  };
const ComponentStateFilterProps = struct {  };
pub fn ComponentSearchInput(
    ctx: *zx.ComponentCtx(ComponentSearchInputProps),
) zx.Component {
    return (
        <div @allocator={ctx.allocator} class="search-input-wrapper">
            <input @allocator={ctx.allocator} oninput={handleComponentSearchInput} type="text" placeholder="Find components..." class="search-input" />
        </div>
    );
}
pub fn ComponentTree(
    ctx: *zx.ComponentCtx(ComponentTreeProps),
) zx.Component {
    return (
        <div @allocator={ctx.allocator} class="component-tree">
            <div class="component-list">
                {for (components) |comp| (<ComponentItem allocator={ctx.allocator} name={comp.name} has_children={comp.has_children} children={comp.children} depth={0} selected={comp.selected} badge={comp.badge} />)}
            </div>
        </div>
    );
}

pub fn ComponentState(
    ctx: *zx.ComponentCtx(ComponentStateProps),
) zx.Component {
    const sel = selected_component.get();
    const maybe_component = findComponentByName(&components, sel);
    
    if (maybe_component) |comp| {
        if (comp.meta) |metadata| {
            return (
                <div @allocator={ctx.allocator} class="component-state-wrapper">
                    <div @allocator={ctx.allocator} class="state-content">
                        <StateSection allocator={ctx.allocator} title="Props" items={metadata.setup_items} />
                        <StateSection allocator={ctx.allocator} title="Signals" items={metadata.setup_other_items} />
                        <StateSection allocator={ctx.allocator} title="Actions" items={metadata.template_refs_items} />
                    </div>
                </div>
            );
        }
    }
    
    return (
        <div @allocator={ctx.allocator} class="component-state-wrapper">
            <div @allocator={ctx.allocator} class="state-content">
                <div class="state-empty">
                    <h2>{sel}</h2>
                    <p>{"No state data available for this component."}</p>
                </div>
            </div>
        </div>
    );
}

pub fn handleComponentSearchInput(ctx: zx.EventContext) void {
    inputvalue = ctx.value() orelse "";
    zx.requestRender();
}

pub fn handleStateFilterInput(ctx: zx.EventContext) void {
    stateFilter = ctx.value() orelse "";
    zx.requestRender();
}

pub fn ComponentStateFilter(
    ctx: *zx.ComponentCtx(ComponentStateFilterProps),
) zx.Component {
    return (
        <div @allocator={ctx.allocator} class="filter-wrapper">
            <input @allocator={ctx.allocator} oninput={handleStateFilterInput} type="text" placeholder="Filter State..." class="filter-input" />
        </div>
    );
}

pub fn handleComponentClick(ctx: zx.EventContext) void {
    const name = ctx.value() orelse "App";
    selected_component.set(name);
    zx.requestRender();
}

const icons = @import("./components/icons.zx");

pub fn Page(ctx: zx.PageContext) zx.Component {
    return (
        <div @allocator={ctx.arena} class="devtools-container">
            <div class="sidebar">
                <div class="search-box">
                    <div class="search-wrapper">
                        <ComponentSearchInput @rendering={.client} />
                        {icons.Search(ctx.arena)}
                        <div class="search-shortcut">â†²</div>
                    </div>
                </div>

                <ComponentTree @rendering={.client} />
            </div>

            <div class="devtools-resize-handle"></div>

            <div class="state-panel">
                <div class="state-header">
                    <span class="state-title" id="state-title">{&selected_component}</span>
                    <ComponentStateFilter @rendering={.client} />
                    <div class="state-actions">
                        {icons.StateEye(ctx.arena)}
                        {icons.StateArrows(ctx.arena)}
                        {icons.StateList(ctx.arena)}
                        {icons.StateExport(ctx.arena)}
                    </div>
                </div>

                <ComponentState @rendering={.client} />

            </div>
        </div>
    );
}

const Component = data.Component;
const ComponentItemProps = struct { name: []const u8, has_children: bool, children: []const Component, depth: usize = 0, selected: bool = false, badge: []const u8 = "" };

fn ComponentItem(allocator: zx.Allocator, props: ComponentItemProps) zx.Component {
    const id = std.fmt.allocPrint(allocator, "comp-{d}-{s}", .{ props.depth, props.name }) catch "";
    const padding = props.depth * 24 + 16;
    const style_str = std.fmt.allocPrint(allocator, "padding-left: {d}px", .{padding}) catch "";
    const item_class = if (props.selected) "component-root" else "component-item";
    const name_class = if (props.selected) "component-name-root" else "component-name";
    const group_class = getComponentGroupClass(props.name, props.has_children, props.children);
    return (
        <div @allocator={allocator} class={group_class}>
            {if (props.has_children) (
                <>
                    <input type="checkbox" id={id} class="component-toggle" checked />
                    <div class={item_class} style={style_str} >
                        <label for={id} class="component-toggle-label">
                            <span class="tree-arrow"></span>
                        </label>
                        <button value={props.name} onclick={handleComponentClick} class="component-select-btn">
                            <span class="bracket">{"<"}</span>
                            <span class={name_class}>{props.name}</span>
                            <span class="bracket">{">"}</span>
                            {if (props.badge.len > 0) (<span class="component-badge">{props.badge}</span>) else ""}
                        </button>
                    </div>
                    <div class="component-children">
                        {for (props.children) |child| (
                            <ComponentItem allocator={allocator} name={child.name} has_children={child.has_children} children={child.children} depth={props.depth + 1} selected={child.selected} badge={child.badge} />
                        )}
                    </div>
                </>
            ) else (
                <div class={item_class} style={style_str}>
                    <button value={props.name} onclick={handleComponentClick} class="component-select-btn-leaf">
                        <span class="tree-arrow-spacer"></span>
                        <span class="bracket">{"<"}</span>
                        <span class={name_class}>{props.name}</span>
                        <span class="bracket">{">"}</span>
                        {if (props.badge.len > 0) (<span class="component-badge">{props.badge}</span>) else ""}
                    </button>
                </div>
            )}
        </div>
    );
}

const StateItem = data.StateItem;
fn StateSection(allocator: zx.Allocator, props: struct { title: []const u8, items: []const StateItem }) zx.Component {
    const id = std.fmt.allocPrint(allocator, "state-section-{s}", .{props.title}) catch "";
    return (
        <div @allocator={allocator} class="state-section">
            <input type="checkbox" id={id} class="state-toggle" checked />
            <label for={id} class="section-header">
                <span class="section-arrow"></span>
                <span class="section-title">{props.title}</span>
            </label>
            <div class="section-items">
                {for (props.items) |item| (
                    <StateItemRow allocator={allocator} item={item} />
                )}
            </div>
        </div>
    );
}

fn StateItemRow(allocator: zx.Allocator, props: struct { item: StateItem, depth: usize = 0 }) zx.Component {
    const item = props.item;
    const has_children = item.children.len > 0;
    const value_color = getValueColor(item.value);
    const padding = props.depth * 18;
    const style_str = std.fmt.allocPrint(allocator, "padding-left: {d}px", .{padding}) catch "";
    const id = std.fmt.allocPrint(allocator, "sr-{d}-{s}", .{ props.depth, item.key }) catch "";
    const group_class = getStateItemGroupClass(item);
    return (
        <div @allocator={allocator} class={group_class} style={style_str}>
            {if (has_children) (
                <>
                    <input type="checkbox" id={id} class="state-row-toggle" />
                    <label for={id} class="state-item">
                        <span class="item-arrow"></span>
                        <span class="key-default">{item.key}</span>
                        <span class="item-colon">:</span>
                        <span class={value_color}>{item.value}</span>
                        {if (item.meta.len > 0) (<span class="item-meta">{item.meta}</span>) else ""}
                    </label>
                    <div class="state-item-children">
                        {for (item.children) |child| (
                            <StateItemRow allocator={allocator} item={child} depth={props.depth + 1} />
                        )}
                    </div>
                </>
            ) else (
                <div class="state-item">
                    <span class="item-spacer"></span>
                    <span class="key-default">{item.key}</span>
                    <span class="item-colon">:</span>
                    <span class={value_color}>{item.value}</span>
                    {if (item.meta.len > 0) (<span class="item-meta">{item.meta}</span>) else ""}
                </div>
            )}
        </div>
    );
}

fn getComponentGroupClass(name: []const u8, has_children: bool, children: []const Component) []const u8 {
    if (componentOrDescendantMatches(name, has_children, children)) return "component-group";
    return "component-group component-group-hidden";
}

fn getStateItemGroupClass(item: StateItem) []const u8 {
    if (stateItemOrDescendantMatches(item)) return "state-item-group";
    return "state-item-group state-item-group-hidden";
}

fn stateItemOrDescendantMatches(item: StateItem) bool {
    if (stateFilter.len == 0) return true;
    if (containsIgnoreCase(item.key, stateFilter)) return true;
    if (containsIgnoreCase(item.value, stateFilter)) return true;
    if (item.meta.len > 0 and containsIgnoreCase(item.meta, stateFilter)) return true;
    for (item.children) |child| {
        if (stateItemOrDescendantMatches(child)) return true;
    }
    return false;
}

fn componentOrDescendantMatches(name: []const u8, has_children: bool, children: []const Component) bool {
    if (inputvalue.len == 0) return true;
    if (containsIgnoreCase(name, inputvalue)) return true;
    if (has_children) {
        for (children) |child| {
            if (componentOrDescendantMatches(child.name, child.has_children, child.children)) return true;
        }
    }
    return false;
}

fn containsIgnoreCase(haystack: []const u8, needle: []const u8) bool {
    if (needle.len > haystack.len) return false;
    var i: usize = 0;
    while (i <= haystack.len - needle.len) : (i += 1) {
        var match = true;
        for (0..needle.len) |j| {
            if (std.ascii.toLower(haystack[i + j]) != std.ascii.toLower(needle[j])) {
                match = false;
                break;
            }
        }
        if (match) return true;
    }
    return false;
}

fn getValueColor(value: []const u8) []const u8 {
    if (std.mem.indexOf(u8, value, "fn") != null) return "value-function";
    if (std.mem.eql(u8, value, "true") or std.mem.eql(u8, value, "false")) return "value-boolean";
    if (std.mem.startsWith(u8, value, "\"")) return "value-string";
    return "value-default";
}

const zx = @import("zx");
const std = @import("std");
const data = @import("data.zig");
